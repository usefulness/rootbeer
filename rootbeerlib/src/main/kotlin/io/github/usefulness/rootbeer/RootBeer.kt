package io.github.usefulness.rootbeer

import android.content.Context
import android.os.Build
import androidx.annotation.WorkerThread
import io.github.usefulness.rootbeer.internal.Consts
import io.github.usefulness.rootbeer.internal.RootBeerWrapper
import java.io.BufferedReader
import java.io.File
import java.io.IOException
import java.io.InputStreamReader
import java.util.Scanner

/**
 * A simple root checker that gives an *indication* if the device is rooted or not.
 * Disclaimer: **root==god**, so there's no 100% way to check for root.
 */
public class RootBeer(private val mContext: Context) {

    private var loggingEnabled = true

    /**
     * Run all the root detection checks.
     *
     * @return true, we think there's a good *indication* of root | false good *indication* of no root (could still be cloaked)
     */
    @get:WorkerThread
    public val isRooted: Boolean
        get() = detectRootManagementApps() ||
            detectPotentiallyDangerousApps() ||
            checkForBinary(Consts.BINARY_SU) ||
            checkForDangerousProps() ||
            checkForRWPaths() ||
            detectTestKeys() ||
            checkSuExists() ||
            checkForRootNative() ||
            checkForMagiskBinary() ||
            checkForMagiskUdsNative()

    /**
     * Run all the checks including checking for the busybox binary.
     * Warning: Busybox binary is not always an indication of root, many manufacturers leave this
     * binary on production devices
     * @return true, we think there's a good *indication* of root | false good *indication* of no root (could still be cloaked)
     */
    @get:WorkerThread
    public val isRootedWithBusyBoxCheck: Boolean
        get() = isRooted || checkForBusyBoxBinary()

    /**
     * Release-Keys and Test-Keys has to do with how the kernel is signed when it is compiled.
     * Test-Keys means it was signed with a custom key generated by a third-party developer.
     * @return true if signed with Test-keys
     */
    public fun detectTestKeys(): Boolean {
        val buildTags = Build.TAGS

        return buildTags != null && buildTags.contains("test-keys")
    }

    /**
     * Using the PackageManager, check for a list of well known root apps. [Consts.knownRootAppsPackages]
     * @param additionalRootManagementApps - array of additional packagenames to search for
     * @return true if one of the apps it's installed
     */
    @JvmOverloads
    public fun detectRootManagementApps(additionalRootManagementApps: List<String> = emptyList()): Boolean =
        isAnyPackageFromListInstalled(packages = Consts.knownRootAppsPackages + additionalRootManagementApps)

    /**
     * Using the PackageManager, check for a list of well known apps that require root. [Consts.knownRootAppsPackages]
     * @param additionalDangerousApps - array of additional packagenames to search for
     * @return true if one of the apps it's installed
     */
    @JvmOverloads
    public fun detectPotentiallyDangerousApps(additionalDangerousApps: List<String> = emptyList()): Boolean =
        isAnyPackageFromListInstalled(packages = Consts.knownDangerousAppsPackages + additionalDangerousApps)

    /**
     * Using the PackageManager, check for a list of well known root cloak apps. [Consts.knownRootAppsPackages]
     * @param additionalRootCloakingApps - array of additional packagenames to search for
     * @return true if one of the apps it's installed
     */
    @JvmOverloads
    public fun detectRootCloakingApps(additionalRootCloakingApps: List<String> = emptyList()): Boolean =
        isAnyPackageFromListInstalled(packages = Consts.knownRootCloakingPackages + additionalRootCloakingApps) ||
            !checkForNativeLibraryReadAccess()

    /**
     * Checks various (Const.suPaths) common locations for the SU binary
     * @return true if found
     */
    public fun checkForSuBinary(): Boolean = checkForBinary(Consts.BINARY_SU)

    /**
     * Checks various (Const.suPaths) common locations for the magisk binary (a well know root level program)
     * @return true if found
     */
    public fun checkForMagiskBinary(): Boolean = checkForBinary("magisk")

    /**
     * Checks various [Consts.suPaths] common locations for the busybox binary (a well know root level program)
     * @return true if found
     */
    public fun checkForBusyBoxBinary(): Boolean = checkForBinary(Consts.BINARY_BUSYBOX)

    /**
     *
     * @param filename - check for this existence of this file
     * @return true if found
     */
    public fun checkForBinary(filename: String): Boolean = Consts.paths.any { path -> File(path, filename).exists() }

    /**
     *
     * @param logging - set to true for logging
     */
    public fun setLogging(logging: Boolean) {
        loggingEnabled = logging
    }

    private fun propsReader(): List<String> {
        try {
            val inputStream = Runtime.getRuntime().exec("getprop").inputStream ?: return emptyList()
            val propVal = inputStream.use { Scanner(inputStream).useDelimiter("\\A").next() }
            return propVal.split("\n".toRegex()).dropLastWhile { it.isEmpty() }
        } catch (ignored: IOException) {
            return emptyList()
        } catch (ignored: NoSuchElementException) {
            return emptyList()
        }
    }

    private fun mountReader(): List<String> {
        try {
            val inputstream = Runtime.getRuntime().exec("mount").inputStream ?: return emptyList()
            val propVal = Scanner(inputstream).useDelimiter("\\A").next()
            return propVal.split("\n".toRegex()).dropLastWhile { it.isEmpty() }
        } catch (ignored: IOException) {
            return emptyList()
        } catch (ignored: NoSuchElementException) {
            return emptyList()
        }
    }

    /**
     * Check if any package in the list is installed
     * @param packages - list of packages to search for
     * @return true if any of the packages are installed
     */
    private fun isAnyPackageFromListInstalled(packages: List<String>) = packages.any {
        runCatching {
            mContext.packageManager.getPackageInfo(it, 0)
            true
        }.getOrDefault(false)
    }

    /**
     * Checks for several system properties for
     * @return - true if dangerous props are found
     */
    public fun checkForDangerousProps(): Boolean {
        val dangerousProps = mapOf(
            "ro.debuggable" to "1",
            "ro.secure" to "0",
        )

        val lines = propsReader()

        for (line in lines) {
            for (key in dangerousProps.keys) {
                if (line.contains(key)) {
                    val badValue = "[${dangerousProps[key]}]"
                    if (line.contains(badValue)) {
                        return true
                    }
                }
            }
        }
        return false
    }

    /**
     * When you're root you can change the permissions on common system directories,
     * this method checks if any of [Consts.pathsThatShouldNotBeWritable] are writable.
     *
     * @return true if one of the dir is writable
     */
    public fun checkForRWPaths(): Boolean {
        var result = false

        // Run the command "mount" to retrieve all mounted directories
        val lines = mountReader()

        // The SDK version of the software currently running on this hardware device.
        val sdkVersion = Build.VERSION.SDK_INT

        /**
         *
         * In devices that are running Android 6 and less, the mount command line has an output as follow:
         *
         * <fs_spec_path> <fs_file> <fs_spec> <fs_mntopts>
         *
         * where :
         * - fs_spec_path: describes the path of the device or remote filesystem to be mounted.
         * - fs_file: describes the mount point for the filesystem.
         * - fs_spec describes the block device or remote filesystem to be mounted.
         * - fs_mntopts: describes the mount options associated with the filesystem. (E.g. "rw,nosuid,nodev" )
         *
         </fs_mntopts></fs_spec></fs_file></fs_spec_path> */
        /** In devices running Android which is greater than Marshmallow, the mount command output is as follow:
         *
         * <fs_spec> <ON> <fs_file> <TYPE> <fs_vfs_type> <(fs_mntopts)>
         *
         * where :
         * - fs_spec describes the block device or remote filesystem to be mounted.
         * - fs_file: describes the mount point for the filesystem.
         * - fs_vfs_type: describes the type of the filesystem.
         * - fs_mntopts: describes the mount options associated with the filesystem. (E.g. "(rw,seclabel,nosuid,nodev,relatime)" )
         </fs_vfs_type></TYPE></fs_file></ON></fs_spec> */
        for (line in lines) {
            // Split lines into parts

            val args = line.split(" ".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()

            if ((sdkVersion <= Build.VERSION_CODES.M && args.size < 4) ||
                (sdkVersion > Build.VERSION_CODES.M && args.size < 6)
            ) {
                // If we don't have enough options per line, skip this and log an error
                continue
            }

            var mountPoint: String
            var mountOptions: String

            /**
             * To check if the device is running Android version higher than Marshmallow or not
             */
            if (sdkVersion > Build.VERSION_CODES.M) {
                mountPoint = args[2]
                mountOptions = args[5]
            } else {
                mountPoint = args[1]
                mountOptions = args[3]
            }

            for (pathToCheck in Consts.pathsThatShouldNotBeWritable) {
                if (mountPoint.equals(pathToCheck, ignoreCase = true)) {
                    /**
                     * If the device is running an Android version above Marshmallow,
                     * need to remove parentheses from options parameter;
                     */

                    if (Build.VERSION.SDK_INT > Build.VERSION_CODES.M) {
                        mountOptions = mountOptions.replace("(", "")
                        mountOptions = mountOptions.replace(")", "")
                    }

                    // Split options out and compare against "rw" to avoid false positives
                    for (option in mountOptions.split(",".toRegex()).dropLastWhile { it.isEmpty() }) {
                        if (option.equals("rw", ignoreCase = true)) {
                            // path is mounted with rw permissions!
                            result = true
                            break
                        }
                    }
                }
            }
        }

        return result
    }

    /**
     * A variation on the checking for SU, this attempts a 'which su'
     * @return true if su found
     */
    public fun checkSuExists(): Boolean {
        var process: Process? = null
        try {
            process = Runtime.getRuntime().exec(arrayOf("which", Consts.BINARY_SU))
            return BufferedReader(InputStreamReader(process.inputStream)).use { it.readLine() != null }
        } catch (ignore: Throwable) {
            return false
        } finally {
            process?.destroy()
        }
    }

    /**
     * Checks if device has ReadAccess to the Native Library
     *
     * Description: RootCloak automatically blocks read access to the Native Libraries, however
     * allows for them to be loaded into memory. This check is an indication that RootCloak is
     * installed onto the device.
     *
     * @return true if device has Read Access | false if UnsatisfiedLinkError Occurs
     */
    public fun checkForNativeLibraryReadAccess(): Boolean {
        if (!RootBeerWrapper.isInitialized()) {
            return false
        }

        try {
            RootBeerWrapper.setLogDebugMessages(loggingEnabled)
            return true
        } catch (ignored: UnsatisfiedLinkError) {
            return false
        }
    }

    /**
     * Native checks are often harder to cloak/trick so here we call through to our native root checker
     * @return true if we found su | false if not, or the native library could not be loaded / accessed
     */
    public fun checkForRootNative(): Boolean {
        val checkPaths = Array(size = Consts.paths.size) { "${Consts.paths[it]}${File.separator}${Consts.BINARY_SU}" }

        try {
            RootBeerWrapper.setLogDebugMessages(loggingEnabled)
            return RootBeerWrapper.checkForRoot(checkPaths)
        } catch (ignored: UnsatisfiedLinkError) {
            return false
        }
    }

    public fun checkForMagiskUdsNative(): Boolean {
        try {
            RootBeerWrapper.setLogDebugMessages(loggingEnabled)
            return RootBeerWrapper.checkForMagiskUDS()
        } catch (ignored: UnsatisfiedLinkError) {
            return false
        }
    }
}
